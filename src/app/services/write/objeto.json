[
  {
    "title": "¿Qué es Angular?",
    "control": "<h1 class=\"ql-align-center\"><strong>¿Qué es Angular?</strong></h1><p class=\"ql-align-justify\">Angular es una plataforma de desarrollo, construida en <strong>Typescript</strong>. Como plataforma Angular incluye: </p><ul><li class=\"ql-align-justify\">Un Framework basado en componentes, para construir aplicaciones web escalables. </li><li class=\"ql-align-justify\">Una colección de librerias bien integradas que cubren una amplia variedad de caracteristicas como incluir Routing, administrar formularioscomunicación cliente-servidor y más.</li><li class=\"ql-align-justify\">Una suite de herramientas para ayudarte a desarrollar, construir, testear y actualizar tu código. </li></ul>",
    "uri": "¿qué-es-angular?",
    "component": "¿QuéEsAngular?Component",
    "path": "¿QuéEsAngular?"
  },
  {
    "title": "Esenciales: Componentes",
    "control": "<h2 class=\"ql-align-justify\"><strong>Componentes</strong></h2><p class=\"ql-align-justify\">Los componentes son bloques para construir que componen una aplicación de Angular. Un componente incluye una clase de <strong>Typescript</strong> con un decorador <strong>@Component()</strong>, una plantilla HTML u estilos. El decorador <strong>@Component()</strong> especifica la siguiente información:</p><ul><li class=\"ql-align-justify\">Un selector que define como el componente es usado en una plantilla. Los elementos HTML en la plantilla que coincidan con este selector se vuelven una instancia del componente.</li><li class=\"ql-align-justify\">Una plantilla HTML que le indica a Angular como reproducir el componente.</li><li class=\"ql-align-justify\">Un set opcional de estilos CSS que definen la apariencia de los elementos HTML de la plantilla.</li></ul><p class=\"ql-align-justify\">Para usar el componente se coloca el selector como un elemento HTML.</p><p><br></p>",
    "uri": "esenciales:-componentes",
    "component": "Esenciales:ComponentesComponent",
    "path": "esenciales:Componentes"
  },
  {
    "title": "Esenciales: Plantillas",
    "control": "<h2 class=\"ql-align-justify\"><strong>Plantillas</strong></h2><p class=\"ql-align-justify\">Cada componente tiene una plantilla HTML que declara como el componente se reproducirá. Tu defines la plantilla inline o por medio de un archivo.</p><p class=\"ql-align-justify\">Angular extiende HTML con sintaxis adicional que te permite insertar valores dinamicos desde tu componente. Llamado <strong>Text Interpolation</strong>.</p><pre class=\"ql-syntax ql-align-justify\" spellcheck=\"false\">{{ variable }}\n</pre><p class=\"ql-align-justify\">Tambien Angular soporta union de propiedades, para ayudarte a colocar valores por propiedades y atributos de elementos HTML y pasar esos valores a la logica de presentación de tu aplicación.</p><pre class=\"ql-syntax ql-align-justify\" spellcheck=\"false\">&lt;p [id]=\"variableId\" [style.color]=\"fontColor\"&gt; Puedes cambiar mi color desde el componente.&lt;/p&gt;\n</pre><p class=\"ql-align-justify\">Nota los corchetes, esa sintaxis nos indica que estas uniendo la propiedad o atributo a un valor en el componente.</p><p class=\"ql-align-justify\">Tambien puedes declarar <strong>Event Listeners</strong> para escuchar y responder a las acciones del usuario tales como tecleos, movimientos del mouse, clicks y toques. Puedes declarar un <strong>Event Listener</strong> especificando el nombre del evento en parentesis.</p><pre class=\"ql-syntax ql-align-justify\" spellcheck=\"false\">&lt;button (click)=\"sayMessage()\" [disabled]=\"canClick\"&gt;Lanza la alerta&lt;/button&gt;\n</pre><p class=\"ql-align-justify\">Este ejemplo calla un metodo, que está definido en la clase del componente:</p><pre class=\"ql-syntax ql-align-justify\" spellcheck=\"false\">sayMessage(){\nalert(this.message);\n}\n</pre><p class=\"ql-align-justify\">Puedes agregar funcionalidades adicionales a tus plantillas a través del uso de las directivas. Las mas populares son <strong>*ngIf</strong> y <strong>*ngFor</strong>. Puedes usar las directivas para realizar una variedad de tareas como modificar dinamicamente la estructura del DOM.</p><blockquote class=\"ql-align-justify\">Nota: Para eliminar el riesgo de ataques de inyección de script. Angular no soporta el elemento <strong>&lt;script&gt;</strong> en los templates. Angular lo ignora y lanza una alerta a la consola del browser.</blockquote><p><br></p>",
    "uri": "esenciales:-plantillas",
    "component": "Esenciales:PlantillasComponent",
    "path": "esenciales:Plantillas"
  },
  {
    "title": "Esenciales: Inyección de Dependencia",
    "control": "<h2><strong>Inyección de Dependencia</strong></h2><p>La inyección de dependencia te permite declarar dependencias de tus clases Typescript sin cuidar la instanciación. En lugar de eso, angular maneja la instanciación por ti. Este patrón de diseño te permite escribir código mas testeable y flexible. </p><p>Para ilustrar como trabaja la inyección de dependencias, considera que los métodos definidos en un servicio puedes usarlos en un componente inyectando en el constructor el servicio. </p>",
    "uri": "esenciales:-inyección-de-dependencia",
    "component": "Esenciales:InyecciónDeDependenciaComponent",
    "path": "esenciales:InyecciónDeDependencia"
  },
  {
    "title": "Esenciales: Librerias First-Party",
    "control": "<h2><strong>Librerias First-Party</strong></h2><p>Los mayores beneficios de Angular se vuelven mas aparentes cuando tu aplicación crece y decides agregar nuevas funcionalidades como por ejemplo, navegación de sitio o una entrada de usuario. </p><p>Ahí es cuando puedes aprovechar la plataforma de angular para incorporar una de las varias librerías First-Party que Angular provee. </p><p>Algunas librerías son: </p><ul><li>Angular Router: Navegación y enrutamiento avanzados del lado del cliente basados ​​en componentes Angular. Soporta <strong>lazy-loading</strong>, rutas anidadas, coincidencia de ruta personalizada y más.</li><li>Angular Forms: Sistema uniforme de participación y validación de formularios. </li><li>Angular HttpClient: Cliente HTTP robusto que puede impulsar una comunicación cliente-servidor más avanzada. </li><li>Angular Animations: Vasto sistema para el manejo de animaciones basadas en el estado de la aplicación.</li><li>Angular PWA: Herramientas para construir una Progressive Web Application (PWA) incluyendo un service worker y un Web app manifest. </li><li>Angular Schematics: Herramientas de scaffolding, refactorización y actualización que simplifican el desarrollo a gran escala. </li></ul>",
    "uri": "esenciales:-librerias-first-party",
    "component": "Esenciales:LibreriasFirst-PartyComponent",
    "path": "esenciales:LibreriasFirst-Party"
  },
  {
    "title": "Componentes: Descripción General",
    "control": "<h2><strong>Descrición Principal</strong></h2><p>Los componentes son el principal bloque de construcción para aplicaciones Angular. Cada componente consiste en: </p><ul><li>Una plantilla HTML que declara lo que se reproduce en la página. </li><li>Una clase typescript que define el comportamiento.</li><li>Un selector CSS que define como el componente sera usado en la plantilla</li><li>Opcionalmente, un estilo CSS aplicado a la plantilla.</li></ul><h3><strong>Creando un Componente</strong></h3><p>La manera mas fácil de crear un componente es con Angular CLI, tambien puedes crear los componentes manualmente.</p><p>Para crear un componente usando el Angular CLI corre el comando: </p><pre class=\"ql-syntax\" spellcheck=\"false\">ng generate component &lt;nombre-del-componente&gt;\n</pre><p>Por default este comando crea:</p><ul><li>Un folder con el nombre del componente.</li><li>Un archivo componente <strong>&lt;nombre-del-componente&gt;.component.ts</strong></li><li>Un archivo plantilla <strong>&lt;nombre-del-componente&gt;.component.html</strong></li><li>Un archivo CSS <strong>&lt;nombre-del-componente&gt;.component.html</strong></li><li>Un archivo de testeo <strong>&lt;nombre-del-componente&gt;.component.spec.ts</strong></li></ul><p>Para crear un componente manualmente: </p><ul><li>Navega al directorio del proyecto.</li><li>Crea un nuevo archivo <strong>&lt;nombre-del-componente&gt;.component.ts</strong></li><li>En la parte superior del archivo importa el Componente.</li></ul><pre class=\"ql-syntax\" spellcheck=\"false\">import { Component } from '@angular/core';\n</pre><ul><li>Después de la declaración de import, agrega el decorador <strong>@Component()</strong></li></ul><pre class=\"ql-syntax\" spellcheck=\"false\">@Component({\n\n})\n</pre><ul><li>Dentro del decorador, escoge un selector CSS</li></ul><pre class=\"ql-syntax\" spellcheck=\"false\">@Component({\n  selector: 'app-nombre-componente',\n})\n</pre><ul><li>Define la plantilla HTML que el componente usará para mostrar la información. En la mayoria d elos casos esta plantilla es un archivo separado.</li></ul><pre class=\"ql-syntax\" spellcheck=\"false\">@Component({\n  selector: 'app-nombre-componente'\n  templateUrl: './nombre-componente.component.html',\n})\n</pre><ul><li>Selecciona los estilos para la plantilla. En la moayoria de los casos se define en un archivo separado.</li></ul><pre class=\"ql-syntax\" spellcheck=\"false\">@Component({\n  selector: 'app-nombre-componente'\n  templateUrl: './nombre-componente.component.html',\n  styleUrls: ['./nombre-componente.component.css']  \n})\n</pre><ul><li>Agrega la clase que incluira el código del componente.</li></ul><pre class=\"ql-syntax\" spellcheck=\"false\">export class NombreComponente{\n\n}\n</pre>",
    "uri": "componentes:-descripción-general",
    "component": "Componentes:DescripciónGeneralComponent",
    "path": "componentes:DescripciónGeneral"
  },
  {
    "title": "Componentes: Lifecycle Hooks",
    "control": "<h2><strong>Lifecycle Hooks</strong></h2><p>Una instancia del componente tiene un ciclo de vida que empieza cuando angular instancia la clase del componente y reproduce o muestra la vista del componente junto con sus vistas secundarias. El ciclo de vida continua con una detección de cambios, que Angular verifica para ver cuando cambian las propiedades vinculadas a datos y actualiza los dos, la vista y la instancia del componente como lo necesite. El ciclo de vida termina cuando Angular destruye la instancia del componente y elimina desde el DOM la plantilla reproducida.</p><p>Su aplicación puede usar el ciclo de vida para aprovechar eventos clave en el ciclo de vida de un componente o directiva con el fin de inicializar nuevas instancias, iniciar la detección de cambios cuando sea necesario, responder a las actualizaciones durante la detección de cambios y limpiar antes de eliminar las instancias.</p><h3><strong>Lifecycle event sequence</strong></h3><p>Despues de que tu aplicación instancia un componete o directiva llamando su constructor, Angular llama el método hook que has implementado en el punto apropiado del ciclo de vida de la instancia.</p><p>Angular ejecuta los métodos en esta la secuencia: </p><ul><li><strong>ngOnChanges()</strong></li></ul><p>\t\t\t- <strong>Propósito</strong> - Responde cuando angular establece o restablece propiedades de entrada enlazadas a datos. El método recibe un objeto <strong>SimpleChange </strong>de actuales o previos valores de propiedad.</p><p>\t\t\t- <strong>Momento</strong> - Llamado antes de <strong>ngOninit()</strong> y cuando uno o mas propiedades data-bound cambian. Nota: Si el componente no tiene entradas o lo usas sin proveer entradas el Framework no llamará el método.</p><ul><li><strong>ngOnInit()</strong></li></ul><p>\t\t\t- <strong>Propósito</strong> - Inicializa la directiva o componente después de que Angular muestre primero las propiedades data-bound y establece la entrada de la directiva o componente.</p><p>\t\t\t- <strong>Momento</strong> - Llamado una sola vez después del primer <strong>ngOnChanges()</strong>.</p><ul><li><strong>ngDoCheck()</strong></li></ul><p>\t\t\t- <strong>Propósito</strong> - Detecta y actúa ante cambios que Angular no puede o no detectará por si mismo.</p><p>\t\t\t- <strong>Momento</strong> - Llamado inmediatamente después de <strong>ngOnChanges() </strong>en cada cambio ejecución de detección de cambios e inmediatamente después de <strong>ngOnInit()</strong> en la primer ejecución. </p><ul><li><strong>ngAfterContentInit()</strong></li></ul><p>\t\t\t- <strong>Propósito</strong> - Responde después de que Angular proyecte contenido externo en la vista del componente o en la vista en la que se encuentra una directiva.</p><p>\t\t\t- <strong>Momento</strong> - Llamado una sola vez después del primer <strong>ngDoCheck()</strong>.</p><ul><li><strong>ngAfterContentChecked()</strong></li></ul><p>\t\t\t- <strong>Propósito</strong> - Responde después de que Angular verifica el contenido proyectado en la directiva o componente.</p><p>\t\t\t- <strong>Momento</strong> - Llamado después de <strong>ngAfterContentInit()</strong> y en cada <strong>ngDoCheck()</strong> subsecuente.</p><ul><li><strong>ngAfterViewInit()</strong></li></ul><p>\t\t\t- <strong>Propósito</strong> - Responde después de que Angular inicialice las vistas del componente y las vistas secundarias.</p><p>\t\t\t- <strong>Momento</strong> - Llamado una vez después del primer <strong>ngAfterContentChecked()</strong>.</p><ul><li><strong>ngAfterViewChecked()</strong></li></ul><p>\t\t\t- <strong>Propósito</strong> - Responde después de que Angular verifica la vista de los componentes y vistas secundarias. </p><p>\t\t\t- <strong>Momento</strong> - Llamado después de <strong>ngAfterViewInit()</strong> y en cada <strong>ngAfterContentChecked()</strong> subsecuente.</p><ul><li><strong>ngOnDestroy()</strong></li></ul><p>\t\t\t- <strong>Propósito</strong> - Limpia justo antes de que Angular destruya la directiva o componente. Cancela suscripciones a Observables y desconecta los event handlers para evitar perdidas de memoria. </p><p>\t\t\t- <strong>Momento</strong> - Llamado inmediatamente antes de que angular destruya la directiva o componente. </p>",
    "uri": "componentes:-lifecycle-hooks",
    "component": "Componentes:LifecycleHooksComponent",
    "path": "componentes:LifecycleHooks"
  },
  {
    "title": "Componentes: Interacción",
    "control": "<h2><strong>Interacción de Componentes</strong></h2><h3><strong>Pasar datos de padre a hijo con enlace Input</strong></h3><p>Para pasar datos de padre a hijo se requiere de un Decorador <strong>@Input() </strong>y en el componente padre se utiliza una propiedad de enlace. </p><p>Componente Hijo:</p><pre class=\"ql-syntax\" spellcheck=\"false\">import { Component, Input } from '@angular/core';\nimport { Hero } from './hero';\n\n@Component({\n  selector: 'app-hero-child',\n  template: `\n    &lt;h3&gt;{{hero.name}} says:&lt;/h3&gt;\n    &lt;p&gt;I, {{hero.name}}, am at your service, {{masterName}}.&lt;/p&gt;\n  `\n})\nexport class HeroChildComponent {\n  @Input() hero: Hero;\n  @Input('master') masterName: string; // tslint:disable-line: no-input-rename\n}\n</pre><p>Componente Padre:</p><pre class=\"ql-syntax\" spellcheck=\"false\">import { Component } from '@angular/core';\nimport { HEROES } from './hero';\n\n@Component({\n  selector: 'app-hero-parent',\n  template: `\n    &lt;h2&gt;{{master}} controls {{heroes.length}} heroes&lt;/h2&gt;\n    &lt;app-hero-child *ngFor=\"let hero of heroes\"\n      [hero]=\"hero\"\n      [master]=\"master\"&gt;\n    &lt;/app-hero-child&gt;\n  `\n})\nexport class HeroParentComponent {\n  heroes = HEROES;\n  master = 'Master';\n}\n</pre><h3><strong>Interceptar cambios en las propiedades de entrada con un setter</strong></h3><p>Usa un setter de propiedades de entrada para interceptar y actuar sobre un valor del padre.</p><p>Setter en el componente hijo: </p><pre class=\"ql-syntax\" spellcheck=\"false\">import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-name-child',\n  template: '&lt;h3&gt;\"{{name}}\"&lt;/h3&gt;'\n})\nexport class NameChildComponent {\n  @Input()\n  get name(): string { return this._name; }\n  set name(name: string) {\n    this._name = (name &amp;&amp; name.trim()) || '&lt;no name set&gt;';\n  }\n  private _name = '';\n}\n</pre><p>Componente padre donde se pasan los distintos nombres: </p><pre class=\"ql-syntax\" spellcheck=\"false\">import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-name-parent',\n  template: `\n  &lt;h2&gt;Master controls {{names.length}} names&lt;/h2&gt;\n  &lt;app-name-child *ngFor=\"let name of names\" [name]=\"name\"&gt;&lt;/app-name-child&gt;\n  `\n})\nexport class NameParentComponent {\n  // Displays 'Dr IQ', '&lt;no name set&gt;', 'Bombasto'\n  names = ['Dr IQ', '   ', '  Bombasto  '];\n}\n</pre><h3><strong>Padre escuchar evento del hijo</strong></h3><p>El componente hijo expone una propiedad EventEmitter con la que emite eventos cuando sucede algo. El padre se une a esa propiedad de evento y reacciona a esos eventos.</p><p>La propiedad EventEmitter del hijo es una propiedad de salida, generalmente adornada con un decorador <strong>@Output()</strong></p><p>El componente hijo emite un evento:</p><pre class=\"ql-syntax\" spellcheck=\"false\">import { Component, EventEmitter, Input, Output } from '@angular/core';\n\n@Component({\n  selector: 'app-voter',\n  template: `\n    &lt;h4&gt;{{name}}&lt;/h4&gt;\n    &lt;button (click)=\"vote(true)\"  [disabled]=\"didVote\"&gt;Agree&lt;/button&gt;\n    &lt;button (click)=\"vote(false)\" [disabled]=\"didVote\"&gt;Disagree&lt;/button&gt;\n  `\n})\nexport class VoterComponent {\n  @Input()  name: string;\n  @Output() voted = new EventEmitter&lt;boolean&gt;();\n  didVote = false;\n\n  vote(agreed: boolean) {\n    this.voted.emit(agreed);\n    this.didVote = true;\n  }\n}\n</pre><p>El componente padre lo capta:</p><pre class=\"ql-syntax\" spellcheck=\"false\">import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-vote-taker',\n  template: `\n    &lt;h2&gt;Should mankind colonize the Universe?&lt;/h2&gt;\n    &lt;h3&gt;Agree: {{agreed}}, Disagree: {{disagreed}}&lt;/h3&gt;\n    &lt;app-voter *ngFor=\"let voter of voters\"\n      [name]=\"voter\"\n      (voted)=\"onVoted($event)\"&gt;\n    &lt;/app-voter&gt;\n  `\n})\nexport class VoteTakerComponent {\n  agreed = 0;\n  disagreed = 0;\n  voters = ['Narco', 'Celeritas', 'Bombasto'];\n\n  onVoted(agreed: boolean) {\n    agreed ? this.agreed++ : this.disagreed++;\n  }\n}\n</pre>",
    "uri": "componentes:-interacción",
    "component": "Componentes:InteracciónComponent",
    "path": "componentes:Interacción"
  },
  {
    "title": "Plantillas: Introducción",
    "control": "<h2><strong>Sintaxis de la plantilla</strong></h2><p>En Angular, una plantilla es un fragmento de HTML Dentro de una plantilla puede usar una sintaxis especial para aprovechar muchas de las características de Angular. </p><p>Cada plantilla en tu aplicación es una sección de HTML que puedes incluir como parte de la página que el navegador muestra. </p><p>Con la sintaxis especial de Angular en tus plantillas, puedes extender el vocabulario HTML de tus aplicaciones. Por ejemplo, angular te ayuda a obtener y establecer valores dinámicos del DOM (Document Object Model) con características como funciones de plantilla integradas, variables, event listening y data binding. </p>",
    "uri": "plantillas:-introducción",
    "component": "Plantillas:IntroducciónComponent",
    "path": "plantillas:Introducción"
  },
  {
    "title": "Plantillas: Text Interpolation",
    "control": "<h2><strong>Text Interpolation</strong></h2><p>La interpolación de texto te permite incorporar dinámicamente valores de cadena en tu plantilla HTML.</p><h3><strong>Mostrando valores con la interpolación</strong></h3><p>La interpolación se refiere a incrustar expresiones en texto marcado. Por default, interpolación usa doble llaves como delimitadores.</p><p>Considera esta variable en el componente:</p><pre class=\"ql-syntax\" spellcheck=\"false\">currentCustomer = 'Maria';\n</pre><p>Puedes usar la interpolación para mostrar el valor de esta variable en la plantilla correspondiente: </p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;h3&gt; Current Customer: {{  currentCustomer }}&lt;/h3&gt;\n</pre><p>Angular reemplaza <strong>currentCustomer</strong> con el valor de la cadena de la propiedad correspondiente del componente. En este caso el valor es Maria.</p><p>Con la interpolación Angular realiza las siguientes tareas: </p><ol><li>Evalúa las expresiones dentro de las dobles llaves.</li><li>Convierte los resultados de la expresiones en cadenas de Texto</li><li>Liga los resultados a cualquier cadena literal adyacente</li><li>Asigna el compuesto a un elemento o propiedad de directiva.</li></ol><h3><strong>Mejores practicas de expresión</strong></h3><ul><li><strong>Usa expresiones cortas</strong>: Usa nombres de propiedades o llamadas a métodos cuando sea posible. Mantén la aplicación y la lógica del negocio en el componente, en donde es fácil de desarrollar y probar.</li><li><strong>Ejecución Rápida</strong>: Angular ejecuta expresiones de plantilla después de cada ciclo de detección de cambios. Algunas actividades asíncronas lanzan ciclos de detección de cambio como lo son las resoluciones de promesa, resultados HTML, eventos de tiempo, presionado de teclas y movimientos del mouse. Las expresiones deben finalizar rápidamente para mantener la experiencia del usuario lo mas eficiente posible, especialmente en dispositivos lentos.  Considera cachear los valores cuando su cálculo requiera de mayores recursos.</li><li><strong>Sin efectos secundarios visibles</strong>: Acorde al modelo de flujo de datos unidireccional de Angular, una expresión de plantilla no debe cambiar ningún estado de la aplicación mas que el valor de la propiedad objetivo. Leer el valor de un componente no debe cambiar otro valor mostrado. La vista debe ser estable a través de una sola pasada de renderizado.</li></ul>",
    "uri": "plantillas:-text-interpolation",
    "component": "Plantillas:TextInterpolationComponent",
    "path": "plantillas:TextInterpolation"
  },
  {
    "title": "Plantillas: Template Statements",
    "control": "<h2><strong>Declaraciones de Plantilla</strong></h2><p>Las declaraciones de plantilla son métodos o propiedades que puedes usar en tu HTML para responder a eventos de usuario. Con las declaraciones de plantilla tu aplicación puede involucrar a los usuarios a través de acciones como mostrar contenido dinámico o enviar formularios.</p><p>En el siguiente ejemplo, la declaración de plantilla <strong>deletedHero()</strong> aparece en comillas a la derecha del símbolo de igual \"<strong>=</strong>\" como en el <strong>(evento)=\"declaracion\"</strong>.</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;button (click)=\"deleteHero()\"&gt;Delete hero&lt;/button&gt;\n</pre><p><br></p>",
    "uri": "plantillas:-template-statements",
    "component": "Plantillas:TemplateStatementsComponent",
    "path": "plantillas:TemplateStatements"
  },
  {
    "title": "Plantillas: Pipes",
    "control": "<h2><strong>Transformar Datos Usando Pipes</strong></h2><p>Usa pipes para transformar cadenas, monto de moneda, fechas, y otra data que mostrar. Los pipes son simples funciones que puedes usar en expresiones de plantilla para aceptar un valor de entrada y regresar un valor transformado.</p><p>Angular provee pipes integrados para transformación de datos típica, incluyendo transformaciones para internacionalización (i18n), que utilizan información de la configuración regional para formatear los datos. </p><p>Estos son los pipes mas comunes: </p><ul><li><strong>DatePipe</strong>: Da formato a un valor de fecha acorde a las reglas locales. </li><li><strong>UpperCasePipe</strong>: Transforma todo el texto a mayúsculas. </li><li><strong>LowerCasePipe</strong>: Transforma todo el texto a minúsculas. </li><li><strong>CurrencyPipe</strong>: Transforma un número a cadena de moneda, formateado según las reglas locales. </li><li><strong>DecimalPipe</strong>: Transforma un numero en una cadena con punto decimal, formateado según las reglas locales.</li><li><strong>PercentPipe</strong>: Transforma un numero a cadena de porcentajes, formateado según las reglas locales. </li></ul><p>Puedes crear tus propios pipes para encapsular transformaciones personalizadas y usar tus pipes personalizadas en las expresiones de plantilla.</p><h3><strong>Usando un Pipe en una plantilla</strong></h3><p>Para aplicar un pipe usa el operador pipe ( <strong>|</strong> ) dentro de una expresión de plantilla como se muestra en el código de ejemplo, junto con el nombre del pipe, que por ejemplo es date para el DatePipe integrado.</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;p&gt;Hoy es: {{ dia | date  }}&lt;/p&gt;\n</pre><p><br></p>",
    "uri": "plantillas:-pipes",
    "component": "Plantillas:PipesComponent",
    "path": "plantillas:Pipes"
  }
]